<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Community Notes Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
      margin: 0;
      padding: 0;
    }
    
    .container {
      max-width: 100%;
      margin: 0;
      padding: 8px;
    }

    .header {
      background: white;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 28px;
    }
    
    .subtitle {
      color: #666;
      font-size: 14px;
    }
    
    .controls {
      background: white;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    select, input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: white;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .checkbox-group input {
      width: auto;
    }
    
    .checkbox-group label {
      font-size: 14px;
      text-transform: none;
      letter-spacing: normal;
    }
    
    button {
      padding: 10px 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
    }
    
    .stats {
      background: white;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .stat {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }
    
    .stat-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .notes-container {
      display: grid;
      gap: 20px;
    }
    
    .note-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s;
      overflow: hidden;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .note-card:hover {
      transform: translateY(-2px);
    }
    
    .note-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .note-meta {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      flex: 1;
    }
    
    .badge {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }
    
    .badge.branch {
      background: #e3f2fd;
      color: #1976d2;
    }
    
    .badge.posted {
      background: #e8f5e9;
      color: #388e3c;
    }
    
    .badge.would-post {
      background: #fff3e0;
      color: #f57c00;
    }
    
    .badge.rejected {
      background: #ffebee;
      color: #c62828;
    }

    .rating-input {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      outline: none;
    }

    .rating-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      cursor: pointer;
      border-radius: 50%;
    }

    .rating-input::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }

    .tweet-text {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 14px;
      line-height: 1.6;
      word-wrap: break-word;
      word-break: normal;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }

    .tweet-media {
      margin-top: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .tweet-media img {
      width: 50%;
      max-width: 400px;
      height: auto;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .tweet-media img:hover {
      transform: scale(1.02);
    }

    @media (max-width: 600px) {
      .tweet-media img {
        width: 100%;
      }
    }

    .tweet-link-button {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 13px;
      transition: transform 0.2s;
      margin-left: 10px;
    }

    .tweet-link-button:hover {
      transform: translateY(-2px);
    }

    .note-text {
      background: #e8f5e9;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 14px;
      line-height: 1.6;
      font-weight: 500;
      word-wrap: break-word;
      word-break: normal;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }
    
    .filter-scores {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
      background: #f0f4f8;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
    }
    
    .score-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 6px;
      font-size: 13px;
    }
    
    .score-label {
      color: #666;
    }
    
    .score-value {
      font-weight: bold;
      color: #333;
    }
    
    .score-value.pass {
      color: #388e3c;
    }
    
    .score-value.fail {
      color: #c62828;
    }
    
    .keywords {
      background: #fff3e0;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
      font-size: 13px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.6;
    }

    .keywords > div {
      margin-bottom: 8px;
    }

    .keywords > div:last-child {
      margin-bottom: 0;
    }

    .keywords strong {
      color: #e65100;
      font-weight: 600;
    }
    
    .reasoning {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.6;
      max-height: 300px;
      overflow-y: auto;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: pre-wrap;
    }

    .reasoning pre {
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      font-family: inherit;
    }
    
    .reasoning h4 {
      margin-bottom: 10px;
      color: #666;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: white;
      font-size: 18px;
    }
    
    .error {
      background: #ffebee;
      color: #c62828;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .note-link {
      color: #667eea;
      text-decoration: none;
      font-size: 12px;
      word-break: break-all;
      overflow-wrap: break-word;
    }

    .note-link:hover {
      text-decoration: underline;
    }
    
    .timestamp {
      color: #999;
      font-size: 12px;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .container {
        padding: 5px;
      }

      .note-card {
        padding: 12px;
        border-radius: 8px;
      }

      .header, .controls, .stats {
        padding: 15px;
        margin-bottom: 15px;
      }

      h1 {
        font-size: 22px;
      }

      .notes-container {
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîç Community Notes Viewer</h1>
      <p class="subtitle">Browse and analyze Community Notes from Airtable</p>
    </div>
    
    <div class="controls">
      <div class="control-group">
        <label>Branch Filter</label>
        <select id="branchFilter">
          <option value="all">All Branches</option>
          <option value="main">main</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Max Results</label>
        <input type="number" id="limitInput" value="50" min="1" max="500">
      </div>
      
      <div class="checkbox-group">
        <input type="checkbox" id="onlyPosted">
        <label for="onlyPosted">Only Posted to X</label>
      </div>
      
      <div class="checkbox-group">
        <input type="checkbox" id="onlyWouldPost">
        <label for="onlyWouldPost">Only Would Be Posted</label>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="hasUrlScore">
        <label for="hasUrlScore">Has URL Score</label>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="hasPositiveClaims">
        <label for="hasPositiveClaims">Has Positive Claims Score</label>
      </div>

      <button onclick="loadNotes()">Refresh</button>
    </div>

    <div class="export-controls" style="margin: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; display: none;" id="exportControls">
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <span id="selectedCount" style="font-weight: 600;">0 notes selected</span>
        <button onclick="selectAll()" style="padding: 5px 10px;">Select All</button>
        <button onclick="deselectAll()" style="padding: 5px 10px;">Deselect All</button>
        <select id="exportFormat" style="padding: 5px;">
          <option value="json">JSON</option>
          <option value="csv">CSV</option>
        </select>
        <button onclick="downloadSelected()" style="padding: 5px 15px; background: #007bff; color: white; border: none; border-radius: 4px;">Download Selected</button>
      </div>
    </div>

    <div class="stats" id="stats">
      <div class="stat">
        <div class="stat-value" id="totalCount">0</div>
        <div class="stat-label">Total Notes</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="postedCount">0</div>
        <div class="stat-label">Posted to X</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="wouldPostCount">0</div>
        <div class="stat-label">Would Be Posted</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="rejectedCount">0</div>
        <div class="stat-label">Rejected</div>
      </div>
    </div>
    
    <div class="notes-container" id="notesContainer">
      <div class="loading">Loading notes...</div>
    </div>
  </div>
  
  <script>
    let allNotes = [];
    let selectedNotes = new Set();
    let displayedNotes = [];

    // Load branches on page load
    async function loadBranches() {
      try {
        const response = await fetch('/api/branches');
        const data = await response.json();
        
        const select = document.getElementById('branchFilter');
        // Keep 'all' and 'main'
        select.innerHTML = '<option value="all">All Branches</option>';
        
        data.branches.forEach(branch => {
          const option = document.createElement('option');
          option.value = branch;
          option.textContent = branch;
          select.appendChild(option);
        });
      } catch (error) {
        console.error('Failed to load branches:', error);
      }
    }
    
    // Helper function to make URLs clickable in text
    function linkifyUrls(text) {
      if (!text) return '';
      // Match URLs starting with http/https
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      return text.replace(urlRegex, (url) => {
        // Remove trailing punctuation that might not be part of the URL
        const cleanUrl = url.replace(/[.,;!?]+$/, '');
        return `<a href="${cleanUrl}" target="_blank" style="color: #667eea; overflow-wrap: anywhere;">${cleanUrl}</a>`;
      });
    }

    async function loadNotes() {
      const container = document.getElementById('notesContainer');
      container.innerHTML = '<div class="loading">Loading notes...</div>';
      
      const branch = document.getElementById('branchFilter').value;
      const limit = document.getElementById('limitInput').value;
      const onlyPosted = document.getElementById('onlyPosted').checked;
      const onlyWouldPost = document.getElementById('onlyWouldPost').checked;
      const hasUrlScore = document.getElementById('hasUrlScore').checked;
      const hasPositiveClaims = document.getElementById('hasPositiveClaims').checked;

      try {
        const params = new URLSearchParams({
          branch,
          limit,
          onlyPosted,
          onlyWouldPost,
        });
        
        const response = await fetch(`/api/notes?${params}`);
        const data = await response.json();
        
        if (data.error) {
          throw new Error(data.message || 'Failed to load notes');
        }
        
        allNotes = data.notes;

        // Apply client-side filters
        let filteredNotes = allNotes;

        // Filter by URL score if checkbox is checked
        if (hasUrlScore) {
          filteredNotes = filteredNotes.filter(note =>
            note.urlFilter !== undefined &&
            note.urlFilter !== null &&
            note.urlFilter !== ''
          );
        }

        // Filter by positive claims score if checkbox is checked
        if (hasPositiveClaims) {
          filteredNotes = filteredNotes.filter(note =>
            note.positiveClaimsFilter !== undefined &&
            note.positiveClaimsFilter !== null &&
            note.positiveClaimsFilter !== ''
          );
        }

        displayedNotes = filteredNotes;
        displayNotes(filteredNotes);
        updateStats(filteredNotes);
        
      } catch (error) {
        container.innerHTML = `<div class="error">Error: ${error.message}</div>`;
        console.error('Failed to load notes:', error);
      }
    }
    
    function updateStats(notes) {
      const posted = notes.filter(n => n.postedToX).length;
      const wouldPost = notes.filter(n => n.wouldBePosted === 1).length;
      const rejected = notes.filter(n => !n.wouldBePosted && !n.postedToX).length;
      const hasUrl = notes.filter(n => n.urlFilter !== undefined && n.urlFilter !== null && n.urlFilter !== '').length;

      document.getElementById('totalCount').textContent = notes.length;
      document.getElementById('postedCount').textContent = posted;
      document.getElementById('wouldPostCount').textContent = wouldPost;
      document.getElementById('rejectedCount').textContent = rejected;

      // Update or add URL score count
      let urlStatElement = document.getElementById('urlCount');
      if (!urlStatElement) {
        // Create new stat element for URL scores
        const statsContainer = document.getElementById('stats');
        const newStat = document.createElement('div');
        newStat.className = 'stat';
        newStat.innerHTML = `
          <div class="stat-value" id="urlCount">${hasUrl}</div>
          <div class="stat-label">Has URL Score</div>
        `;
        statsContainer.appendChild(newStat);
      } else {
        urlStatElement.textContent = hasUrl;
      }
    }
    
    function displayNotes(notes) {
      const container = document.getElementById('notesContainer');
      
      if (notes.length === 0) {
        container.innerHTML = '<div class="error">No notes found matching your criteria</div>';
        return;
      }
      
      container.innerHTML = notes.map(note => {
        // Parse reasoning, keywords, and URL from full result
        let reasoning = '';
        let keywords = '';
        let entities = '';
        let claims = '';
        let noteUrl = '';

        if (note.fullResult) {
          const lines = note.fullResult.split('\n');

          // Find keywords section
          const keywordsIndex = lines.findIndex(line => line.includes('KEYWORDS EXTRACTED'));
          if (keywordsIndex !== -1) {
            for (let i = keywordsIndex + 1; i < Math.min(keywordsIndex + 5, lines.length); i++) {
              const line = lines[i];
              if (line.startsWith('- Keywords:')) {
                keywords = line.replace('- Keywords:', '').trim();
              } else if (line.startsWith('- Entities:')) {
                entities = line.replace('- Entities:', '').trim();
              } else if (line.startsWith('- Claims:')) {
                claims = line.replace('- Claims:', '').trim();
              }
            }
          }

          // Find the URL for the note
          const urlLine = lines.find(line => line.startsWith('URL: '));
          if (urlLine) {
            noteUrl = urlLine.replace('URL: ', '').trim();
          }

          // Find reasoning section
          const reasoningStart = lines.findIndex(line =>
            line.includes('SKIP REASON') ||
            line.includes('STATUS') ||
            line.includes('FILTER')
          );
          if (reasoningStart !== -1) {
            reasoning = lines.slice(reasoningStart, reasoningStart + 10).join('\n');
          }
        }
        
        // Determine status badges
        const badges = [];
        badges.push(`<span class="badge branch">${note.botName || 'Unknown'}</span>`);
        
        if (note.postedToX) {
          badges.push('<span class="badge posted">Posted to X</span>');
        } else if (note.wouldBePosted === 1) {
          badges.push('<span class="badge would-post">Would Post</span>');
        } else {
          badges.push('<span class="badge rejected">Rejected</span>');
        }
        
        // Build filter scores HTML
        let scoresHtml = '';
        const scores = [
          { label: 'Not Sarcasm', value: note.notSarcasmFilter, threshold: 0.5 },
          { label: 'URL Valid', value: note.urlFilter, threshold: 0.5 },
          { label: 'Character Count', value: note.characterCountFilter, threshold: 0.5 },
          { label: 'Positive Claims', value: note.positiveClaimsFilter, threshold: 0.5 },
          { label: 'Significant Correction', value: note.significantCorrectionFilter, threshold: 0.5 },
        ];

        const validScores = scores.filter(s => s.value !== undefined && s.value !== null);

        // Always show the scores section with whatever scores are available
        scoresHtml = `
          <div class="filter-scores" style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-top: 10px; border: 1px solid #dee2e6;">
            <h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px; font-weight: 600;">Filter Scores:</h4>
            ${validScores.length > 0 ? validScores.map(s => `
              <div class="score-item" style="display: inline-block; margin-right: 15px; margin-bottom: 5px;">
                <span class="score-label" style="color: #6c757d; font-size: 13px;">${s.label}:</span>
                <span class="score-value ${s.value >= s.threshold ? 'pass' : 'fail'}" style="font-weight: 600; margin-left: 5px; color: ${s.value >= s.threshold ? '#28a745' : '#dc3545'};">
                  ${typeof s.value === 'number' ? s.value.toFixed(2) : s.value}
                </span>
              </div>
            `).join('') : '<span style="color: #6c757d; font-size: 13px;">No filter scores available for this note</span>'}
          </div>
        `;
        
        // Keywords, Entities, and Claims
        let extractedInfoHtml = '';
        if (keywords || entities || claims || note.keywordsExtracted) {
          extractedInfoHtml = `
            <div class="keywords">
              ${keywords ? `<div><strong>Keywords:</strong> ${keywords}</div>` : (note.keywordsExtracted ? `<div><strong>Keywords:</strong> ${note.keywordsExtracted}</div>` : '')}
              ${entities ? `<div><strong>Entities:</strong> ${entities}</div>` : ''}
              ${claims ? `<div><strong>Claims:</strong> ${claims}</div>` : ''}
            </div>
          `;
        }
        
        // Tweet text (from tweetBody if available, otherwise from tweetText)
        let tweetContent = note.tweetText || '';
        let tweetMedia = [];
        if (note.tweetBody) {
          if (note.tweetBody.text) {
            tweetContent = note.tweetBody.text;
          }
          // Extract media if available
          if (note.tweetBody.media && Array.isArray(note.tweetBody.media)) {
            tweetMedia = note.tweetBody.media;
          }
        }

        // Format media HTML
        let mediaHtml = '';
        if (tweetMedia.length > 0) {
          const images = tweetMedia
            .filter(m => m.type === 'photo' || m.url)
            .map(m => {
              const imageUrl = m.url || m.media_url_https || m.media_url;
              if (imageUrl) {
                return `<img src="${imageUrl}" alt="Tweet media" onclick="window.open('${imageUrl}', '_blank')">`;
              }
              return '';
            })
            .filter(img => img);

          if (images.length > 0) {
            mediaHtml = `<div class="tweet-media">${images.join('')}</div>`;
          }
        }

        return `
          <div class="note-card" data-note-id="${note.id}">
            <div class="note-header">
              <div class="note-meta">
                <input type="checkbox" class="note-select" data-note-id="${note.id}" onchange="toggleNoteSelection('${note.id}')" style="margin-right: 10px;">
                ${badges.join('')}
                ${note.createdTime ? `<span class="timestamp">${new Date(note.createdTime).toLocaleString()}</span>` : ''}
                <a href="${note.url}" target="_blank" class="tweet-link-button">View Tweet ‚Üí</a>
              </div>
            </div>

            ${tweetContent ? `
              <div class="tweet-text">
                <strong>Tweet:</strong><br>
                ${linkifyUrls(tweetContent)}
                ${mediaHtml}
              </div>
            ` : ''}
            
            ${note.finalNote ? `
              <div class="note-text">
                <strong>Community Note:</strong><br>
                ${linkifyUrls(note.finalNote)}
                ${noteUrl ? `<br><br>${linkifyUrls(noteUrl)}` : ''}
              </div>
            ` : ''}

            <div class="rating-slider" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
              <label style="display: block; margin-bottom: 8px; font-weight: 500;">Would Nathan have posted? <span id="rating-value-${note.id}" style="color: #667eea;">${note.nathanRating !== undefined ? (note.nathanRating * 100).toFixed(0) + '%' : 'Not rated'}</span></label>
              <input type="range"
                     min="0"
                     max="100"
                     value="${note.nathanRating !== undefined ? note.nathanRating * 100 : 50}"
                     class="rating-input"
                     data-note-id="${note.id}"
                     oninput="updateRatingDisplay('${note.id}', this.value)"
                     onchange="saveRating('${note.id}', this.value)"
                     style="width: 100%; cursor: pointer;">
            </div>

            ${extractedInfoHtml}
            ${scoresHtml}
            
            ${reasoning ? `
              <div class="reasoning">
                <h4>Processing Details:</h4>
                <pre>${reasoning}</pre>
              </div>
            ` : ''}
          </div>
        `;
      }).join('');

      // Show/hide export controls based on whether we have notes
      document.getElementById('exportControls').style.display = notes.length > 0 ? 'block' : 'none';
      updateSelectedCount();
    }

    // Selection functions
    function toggleNoteSelection(noteId) {
      if (selectedNotes.has(noteId)) {
        selectedNotes.delete(noteId);
      } else {
        selectedNotes.add(noteId);
      }
      updateSelectedCount();
    }

    function selectAll() {
      displayedNotes.forEach(note => selectedNotes.add(note.id));
      document.querySelectorAll('.note-select').forEach(checkbox => {
        checkbox.checked = true;
      });
      updateSelectedCount();
    }

    function deselectAll() {
      selectedNotes.clear();
      document.querySelectorAll('.note-select').forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedCount();
    }

    function updateSelectedCount() {
      document.getElementById('selectedCount').textContent = `${selectedNotes.size} notes selected`;
    }

    // Download functions
    function downloadSelected() {
      if (selectedNotes.size === 0) {
        alert('Please select at least one note to download');
        return;
      }

      const format = document.getElementById('exportFormat').value;
      const selectedData = displayedNotes.filter(note => selectedNotes.has(note.id));

      if (format === 'json') {
        downloadJSON(selectedData);
      } else if (format === 'csv') {
        downloadCSV(selectedData);
      }
    }

    function downloadJSON(data) {
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `community_notes_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Rating slider functions
    function updateRatingDisplay(noteId, value) {
      const displayElement = document.getElementById(`rating-value-${noteId}`);
      if (displayElement) {
        displayElement.textContent = value + '%';
      }
    }

    async function saveRating(noteId, value) {
      const rating = parseInt(value) / 100; // Convert to 0-1 scale

      try {
        const response = await fetch(`/api/notes/${noteId}/rating`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ rating }),
        });

        if (!response.ok) {
          throw new Error('Failed to save rating');
        }

        console.log(`Saved rating for ${noteId}: ${rating}`);
      } catch (error) {
        console.error('Error saving rating:', error);
        alert('Failed to save rating. Please try again.');
      }
    }

    function downloadCSV(data) {
      // Define CSV headers
      const headers = [
        'ID', 'URL', 'Bot Name', 'Tweet Text', 'Final Note',
        'Would Be Posted', 'Posted to X', 'Created Time',
        'Not Sarcasm Score', 'URL Score', 'Character Count Score',
        'Positive Claims Score', 'Significant Correction Score',
        'Keywords Extracted'
      ];

      // Convert data to CSV rows
      const rows = data.map(note => [
        note.id || '',
        note.url || '',
        note.botName || '',
        (note.tweetText || '').replace(/"/g, '""'), // Escape quotes
        (note.finalNote || '').replace(/"/g, '""'),
        note.wouldBePosted || '',
        note.postedToX || '',
        note.createdTime || '',
        note.notSarcasmFilter || '',
        note.urlFilter || '',
        note.characterCountFilter || '',
        note.positiveClaimsFilter || '',
        note.significantCorrectionFilter || '',
        (note.keywordsExtracted || '').replace(/"/g, '""')
      ]);

      // Create CSV content
      let csv = headers.join(',') + '\n';
      csv += rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

      // Download
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `community_notes_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Initialize
    loadBranches();
    loadNotes();
  </script>
</body>
</html>